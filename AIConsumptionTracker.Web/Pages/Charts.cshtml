@page "/charts"
@model ChartsModel
@{
    ViewData["Title"] = "Charts";
}

<h1 class="page-title">Usage Over Time</h1>

@if (!Model.IsDatabaseAvailable)
{
    <div class="alert alert-warning">
        Database not found. The Agent must run first.
    </div>
}
else
{
    <div class="chart-controls mb-2">
        <select id="timeRange" class="theme-select" style="width: auto;">
            <option value="6">Last 6 hours</option>
            <option value="12">Last 12 hours</option>
            <option value="24" selected>Last 24 hours</option>
            <option value="48">Last 48 hours</option>
            <option value="168">Last 7 days</option>
        </select>
    </div>
    
    <div class="chart-container">
        <canvas id="usageChart"></canvas>
    </div>
    
    @if (Model.ChartData?.Any() != true)
    {
        <div class="alert alert-info">
            No historical data available yet.
        </div>
    }
}

@section Scripts {
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        const chartData = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.ChartData ?? new List<AIConsumptionTracker.Web.Services.ChartDataPoint>()));
        const resetEvents = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.ResetEvents ?? new List<AIConsumptionTracker.Web.Services.ResetEvent>()));
        const providerColors = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.ProviderColors ?? new Dictionary<string, string>()));
        
        function initChart(hours) {
            const ctx = document.getElementById('usageChart');
            if (!ctx) return;
            
            // Filter data by time range
            const cutoff = new Date();
            cutoff.setHours(cutoff.getHours() - hours);
            const filteredData = chartData.filter(d => new Date(d.Timestamp) >= cutoff);
            const filteredResets = resetEvents.filter(r => new Date(r.Timestamp) >= cutoff);
            
            if (filteredData.length === 0) {
                // No data to display
                return;
            }
            
            // Group by provider
            const providers = [...new Set(filteredData.map(d => d.ProviderName))].sort();
            const colors = {
                'Antigravity': '#ef4444', // Red
                'Anthropic': '#ec4899', // Pink
                'OpenAI': '#22c55e', // Green
                'GitHub Copilot': '#3b82f6', // Blue
                'OpenCode ': '#eab308' // Yellow
            };
            const defaultColors = ['#06b6d4', '#8b5cf6', '#f97316', '#64748b'];

            function getColor(name, index) {
                // Check user config first
                if (providerColors[name]) return providerColors[name];
                
                for (const key in colors) {
                    if (name.includes(key)) return colors[key];
                }
                return defaultColors[index % defaultColors.length];
            }
            
            // Get unique timestamps for labels (sorted), merging data points and reset events
            const allTimestamps = [...new Set([
                ...filteredData.map(d => d.Timestamp),
                ...filteredResets.map(r => r.Timestamp)
            ])].sort();

            const labels = allTimestamps.map(ts => {
                const date = new Date(ts);
                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            });
            
            // Create datasets with aligned data points
            const datasets = providers.map((name, i) => {
                const providerData = filteredData.filter(d => d.ProviderName === name);
                const color = getColor(name, i);
                
                // Map data to the unified timeline. 
                // We use 'spanGaps: true' so we don't need to fill every single point, 
                // but Chart.js needs nulls for alignment.
                const data = allTimestamps.map(ts => {
                    const point = providerData.find(d => d.Timestamp === ts);
                    return point ? point.RequestsPercentage : null;
                });
                
                return {
                    label: name,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '20', // transparent fill
                    fill: false,
                    tension: 0.1,
                    pointRadius: data.filter(x => x !== null).length === 1 ? 4 : 2, // Larger radius if only 1 point exists
                    pointHoverRadius: 6,
                    spanGaps: true
                };
            });
            
            // Destroy existing chart if present
            if (window.usageChartInstance) {
                window.usageChartInstance.destroy();
            }

            const resetLinePlugin = {
                id: 'resetLines',
                afterDraw: (chart) => {
                    const ctx = chart.ctx;
                    const xAxis = chart.scales.x;
                    const yAxis = chart.scales.y;

                    filteredResets.forEach(reset => {
                        const x = xAxis.getPixelForTick(allTimestamps.indexOf(reset.Timestamp));
                        if (x < xAxis.left || x > xAxis.right) return; // Clip if out of view

                        // Find provider color
                        const providerIndex = providers.indexOf(reset.ProviderName);
                        // If not found (provider has no data points but has reset), skip or use gray
                        let color = '#999999';
                        if (providerIndex !== -1) {
                             color = datasets[providerIndex].borderColor;
                             // Only draw if the dataset is visible
                             if (chart.isDatasetVisible(providerIndex) === false) return;
                        }

                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(x, yAxis.top);
                        ctx.lineTo(x, yAxis.bottom);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = color;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.restore();
                    });
                }
            };
            
            window.usageChartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    scales: {
                        x: {
                            title: { display: false },
                            ticks: { maxRotation: 45, minRotation: 45, maxTicksLimit: 20 }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Usage %' }
                        }
                    },
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 12, padding: 15 } },
                        tooltip: {
                            callbacks: {
                                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y?.toFixed(1) ?? '-'}%`
                            }
                        }
                    }
                },
                plugins: [resetLinePlugin]
            });
        }
        
        document.getElementById('timeRange')?.addEventListener('change', e => {
            const hours = parseInt(e.target.value);
            initChart(hours);
        });
        
        // Initialize with default 24 hours
        initChart(24);
    </script>
}
