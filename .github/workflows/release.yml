name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.7.5)'
        required: true
        type: string
        force_create:
          description: 'Force tag creation even if validation fails (use with caution)'
          type: boolean
          default: false

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      version_valid: ${{ steps.validate-version.outputs.version_valid }}
      versions_match: ${{ steps.validate-version.outputs.versions_match }}
      changelog_updated: ${{ steps.validate-changelog.outputs.changelog_updated }}
      all_valid: ${{ steps.validate-version.outputs.all_valid }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Validate Version
        id: validate-version
        run: |
          version="${{ inputs.version }}"
          echo "Validating version: $version"

          # Extract version parts (major.minor.patch)
          if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]}
            patch=${BASH_REMATCH[3]}
          else
            echo "ERROR: Invalid version format. Use semantic versioning (e.g., 1.7.5)"
            exit 1
          fi

          echo "version=$version" >> $GITHUB_OUTPUT
          echo "major=$major" >> $GITHUB_OUTPUT
          echo "minor=$minor" >> $GITHUB_OUTPUT
          echo "patch=$patch" >> $GITHUB_OUTPUT

      - name: Check .csproj Files
        id: check-csproj
        run: |
          version="${{ inputs.version }}"
          # Extract version parts
          if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]}
            patch=${BASH_REMATCH[3]}
          fi

          version_valid=true
          versions_match=true
          errors=""

          # Check all .csproj files
          for file in AIConsumptionTracker.Core/AIConsumptionTracker.Core.csproj \
                     AIConsumptionTracker.Infrastructure/AIConsumptionTracker.Infrastructure.csproj \
                     AIConsumptionTracker.UI/AIConsumptionTracker.UI.csproj \
                     AIConsumptionTracker.CLI/AIConsumptionTracker.CLI.csproj; do
            if [ ! -f "$file" ]; then
              echo "WARNING: File not found: $file"
              version_valid=false
              continue
            fi

            # Check version in file
            if grep -q "<Version>$version</Version>" "$file"; then
              echo "✓ $file: $version"
            else
              version_valid=false
              versions_match=false
              errors="$errors$file: Expected $version but found different or no version"$versions_match=false"
              echo "ERROR: $file has wrong version"
            fi
          done

          echo "version_valid=$version_valid" >> $GITHUB_OUTPUT
          echo "versions_match=$versions_match" >> $GITHUB_OUTPUT

      - name: Check CHANGELOG.md
        id: check-changelog
        run: |
          version="${{ inputs.version }}"
          # Extract version parts
          if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]}
            patch=${BASH_REMATCH[3]}
          fi

          changelog_valid=true
          errors=""

          # Check if CHANGELOG has version section
          if grep -q "## \[$version\]" CHANGELOG.md; then
            echo "✓ CHANGELOG.md has version section for $version"
          else
            changelog_valid=false
            errors="$errorsCHANGELOG.md: Missing version section for $version. Expected '## [$version] - YYYY-MM-DD'"changelog_valid=false
          fi

          echo "changelog_updated=$changelog_valid" >> $GITHUB_OUTPUT

      - name: Check README.md
        id: check-readme
        run: |
          version="${{ inputs.version }}"
          # Extract version parts
          if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]}
            patch=${BASH_REMATCH[3]}
          fi

          readme_valid=true
          errors=""

          # Check version badge in README
          if grep -q "version-$version-blue" README.md; then
            echo "✓ README.md has version badge for $version"
          else
            readme_valid=false
            errors="$errorsREADME.md: Version badge does not match $version. Expected 'version-$version-blue'"readme_valid=false
          fi

          echo "readme_valid=$readme_valid" >> $GITHUB_OUTPUT

      - name: Check scripts
        id: check-scripts
        run: |
          version="${{ inputs.version }}"
          # Extract version parts
          if [[ "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]}
            patch=${BASH_REMATCH[3]}
          fi

          scripts_valid=true
          errors=""

          # Check setup.iss
          if grep -q "MyAppVersion \"$version\"" scripts/setup.iss; then
            echo "✓ setup.iss has version $version"
          else
            scripts_valid=false
            errors="$errorssetup.iss: Version does not match $version. Expected 'MyAppVersion \"$version\"'"scripts_valid=false
          fi

          # Check publish-app.ps1
          if grep -q "Version $version" scripts/publish-app.ps1; then
            echo "✓ publish-app.ps1 has version $version"
          else
            scripts_valid=false
            errors="$errorspublish-app.ps1: Version does not match $version. Expected 'Version $version'"scripts_valid=false
          fi

          echo "scripts_valid=$scripts_valid" >> $GITHUB_OUTPUT

      - name: Set All Valid Status
        id: set-all-valid
        run: |
          if [ "${{ needs.validate-version.outputs.version_valid }}" == "true" ] && \
             [ "${{ needs.validate-version.outputs.versions_match }}" == "true" ] && \
             [ "${{ needs.validate-version.outputs.changelog_updated }}" == "true" ] && \
             [ "${{ needs.validate-version.outputs.readme_valid }}" == "true" ] && \
             [ "${{ needs.validate-version.outputs.scripts_valid }}" == "true" ]; then
            all_valid=true
          else
            all_valid=false
          fi

          echo "all_valid=$all_valid" >> $GITHUB_OUTPUT

      - name: Create Git Tag
        run: |
          version="${{ inputs.version }}"
          git tag "v$version"
          git push origin "v$version"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          version="${{ inputs.version }}"
          # Get commit for version (find the last commit mentioning this version)
          commit_sha=$(git log --grep "## \\[$version\\]" --max-count=1 --format="%H")

          # Create release with manual body (GitHub auto-generates notes from commits)
          gh release create "v$version" \
            --title "Release v$version" \
            --target "main" \
            --notes "See CHANGELOG.md for details"

      - name: Success
        run: |
          echo "✅ Successfully created release v${{ inputs.version }}"
          echo "Git tag pushed: v${{ inputs.version }}"
          echo "GitHub release created"

    fail-on-error:
      if: ${{ needs.validate.outputs.all_valid != 'true' && !inputs.force_create }}
        run: |
          echo "⚠️ Validation failed but force_create=true"
          echo "Proceeding anyway - this may create an incomplete release"
